# 15 3Sum

![Top Interview 150](https://img.shields.io/badge/Top_Interview_150-6CC644?style=flat-square)
![Medium](https://img.shields.io/badge/Medium-ffb800?style=flat-square)

Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

**Example:**

```java
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
// Explanation:
// nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
// nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
// nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
// The distinct triplets are [-1,0,1] and [-1,-1,2].
// Notice that the order of the output and the order of the triplets does not matter.
```

```java
Input: nums = [0,1,1]
Output: []
// Explanation: The only possible triplet does not sum up to 0.
```

```java
Input: nums = [0,0,0]
Output: [[0,0,0]]
// Explanation: The only possible triplet sums up to 0.
```

**Constraints:**

- `3 <= nums.length <= 3000`
- `-10⁵ <= nums[i] <= 10⁵`

## Approach

| Topics                       | Category | Key Idea                                                                                      | Time Complexity | Space Complexity |
| ---------------------------- | -------- | --------------------------------------------------------------------------------------------- | --------------- | ---------------- |
| Array, Two Pointers, Sorting | In-place | Sort array, fix one number, then use left/right pointers to find pairs that sum to the target | O(n²)           | O(1)             |

1. Sort the array in ascending order
2. Iterate through the array with index `i`, fixing `nums[i]` as the first number
3. Skip duplicate values for `i` to avoid repeated triplets
4. Use two pointers: `j = i + 1` (left) and `k = nums.length - 1` (right)
5. Calculate `sum = nums[i] + nums[j] + nums[k]`
    - If `sum == 0`, record the triplet, skip duplicate values for both `j` and `k` then move both pointers inward
    - If `sum < 0`, move `j` right to increase the sum
    - If `sum > 0`, move `k` left to decrease the sum
6. Continue until all unique triplets are found

### Complexity

n = `nums.length`

1. **Time Complexity:** O(n²)
    - Array operation `sort`: O(n log n)
    - Loops: O(n²)
        - Outer for loop: O(n)
        - Inner while loop with two pointers: O(n)

2. **Space Complexity:** O(1)
    - constant space, only two pointers and variables used
    - output array is not counted

## Notes

- Skip duplicates at all levels to ensure all triplets are unique.
